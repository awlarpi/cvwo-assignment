// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateUser = `-- name: ActivateUser :exec
UPDATE users SET is_active = TRUE WHERE user_id = $1
`

// Activate a user
func (q *Queries) ActivateUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, activateUser, userID)
	return err
}

const createBookmark = `-- name: CreateBookmark :exec

INSERT INTO bookmarks (user_id, post_id) VALUES ($1, $2)
`

type CreateBookmarkParams struct {
	UserID pgtype.Int4
	PostID pgtype.Int4
}

// ----------------------------------------------------------------------------------------------------------------------
// Create a new bookmark
func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) error {
	_, err := q.db.Exec(ctx, createBookmark, arg.UserID, arg.PostID)
	return err
}

const createCategory = `-- name: CreateCategory :exec

INSERT INTO categories (name, description)
VALUES ($1, $2)
`

type CreateCategoryParams struct {
	Name        string
	Description pgtype.Text
}

// ----------------------------------------------------------------------------------------------------------------------
// Create a new category
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.db.Exec(ctx, createCategory, arg.Name, arg.Description)
	return err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (content, post_id, user_id) VALUES ($1, $2, $3) RETURNING comment_id, content, creation_date, post_id, user_id
`

type CreateCommentParams struct {
	Content string
	PostID  pgtype.Int4
	UserID  pgtype.Int4
}

// Create a new comment
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Content, arg.PostID, arg.UserID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.Content,
		&i.CreationDate,
		&i.PostID,
		&i.UserID,
	)
	return i, err
}

const createEvent = `-- name: CreateEvent :exec
INSERT INTO events (title, description, event_date, meeting_point, route_id, creator_user_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateEventParams struct {
	Title         string
	Description   pgtype.Text
	EventDate     pgtype.Timestamptz
	MeetingPoint  string
	RouteID       pgtype.Int4
	CreatorUserID pgtype.Int4
}

// Create a new event
func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.EventDate,
		arg.MeetingPoint,
		arg.RouteID,
		arg.CreatorUserID,
	)
	return err
}

const createLog = `-- name: CreateLog :exec

INSERT INTO forum_moderation_log (action, moderator_user_id, affected_user_id, post_id, comment_id, reason)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateLogParams struct {
	Action          string
	ModeratorUserID pgtype.Int4
	AffectedUserID  pgtype.Int4
	PostID          pgtype.Int4
	CommentID       pgtype.Int4
	Reason          pgtype.Text
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) error {
	_, err := q.db.Exec(ctx, createLog,
		arg.Action,
		arg.ModeratorUserID,
		arg.AffectedUserID,
		arg.PostID,
		arg.CommentID,
		arg.Reason,
	)
	return err
}

const createPost = `-- name: CreatePost :exec

INSERT INTO posts (title, content, user_id, post_category_id, additional_notes)
VALUES ($1, $2, $3, $4, $5)
`

type CreatePostParams struct {
	Title           string
	Content         string
	UserID          pgtype.Int4
	PostCategoryID  pgtype.Int4
	AdditionalNotes pgtype.Text
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) error {
	_, err := q.db.Exec(ctx, createPost,
		arg.Title,
		arg.Content,
		arg.UserID,
		arg.PostCategoryID,
		arg.AdditionalNotes,
	)
	return err
}

const createPrivateMessage = `-- name: CreatePrivateMessage :exec

INSERT INTO private_messages (content, sender_user_id, receiver_user_id)
VALUES ($1, $2, $3)
`

type CreatePrivateMessageParams struct {
	Content        string
	SenderUserID   pgtype.Int4
	ReceiverUserID pgtype.Int4
}

// ----------------------------------------------------------------------------------------------------------------------
// Create a new private message
func (q *Queries) CreatePrivateMessage(ctx context.Context, arg CreatePrivateMessageParams) error {
	_, err := q.db.Exec(ctx, createPrivateMessage, arg.Content, arg.SenderUserID, arg.ReceiverUserID)
	return err
}

const createRSVP = `-- name: CreateRSVP :exec
INSERT INTO rsvps (event_id, user_id) VALUES ($1, $2)
`

type CreateRSVPParams struct {
	EventID pgtype.Int4
	UserID  pgtype.Int4
}

// Create a new RSVP
func (q *Queries) CreateRSVP(ctx context.Context, arg CreateRSVPParams) error {
	_, err := q.db.Exec(ctx, createRSVP, arg.EventID, arg.UserID)
	return err
}

const createRole = `-- name: CreateRole :exec

INSERT INTO roles (role_name) VALUES ($1)
`

// ----------------------------------------------------------------------------------------------------------------------
// Create a new role
func (q *Queries) CreateRole(ctx context.Context, roleName string) error {
	_, err := q.db.Exec(ctx, createRole, roleName)
	return err
}

const createRoute = `-- name: CreateRoute :exec
INSERT INTO routes (name, description, start_location, end_location, distance, elevation_gain, route_map_link, user_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateRouteParams struct {
	Name          string
	Description   pgtype.Text
	StartLocation string
	EndLocation   string
	Distance      pgtype.Float8
	ElevationGain pgtype.Int4
	RouteMapLink  pgtype.Text
	UserID        pgtype.Int4
}

// Create a new route
func (q *Queries) CreateRoute(ctx context.Context, arg CreateRouteParams) error {
	_, err := q.db.Exec(ctx, createRoute,
		arg.Name,
		arg.Description,
		arg.StartLocation,
		arg.EndLocation,
		arg.Distance,
		arg.ElevationGain,
		arg.RouteMapLink,
		arg.UserID,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, email, password_hash, profile_picture, biography, role_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateUserParams struct {
	Username       string
	Email          string
	PasswordHash   string
	ProfilePicture pgtype.Text
	Biography      pgtype.Text
	RoleID         pgtype.Int4
}

// Create a new user
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.ProfilePicture,
		arg.Biography,
		arg.RoleID,
	)
	return err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO user_sessions (session_id, user_id, expiry_date, ip_address, user_agent) VALUES ($1, $2, $3, $4, $5)
RETURNING session_id, user_id, creation_date, expiry_date, ip_address, user_agent
`

type CreateUserSessionParams struct {
	SessionID  pgtype.UUID
	UserID     pgtype.Int4
	ExpiryDate pgtype.Timestamptz
	IpAddress  *netip.Addr
	UserAgent  pgtype.Text
}

// Insert a new user session and return the created session
func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession,
		arg.SessionID,
		arg.UserID,
		arg.ExpiryDate,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i UserSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreationDate,
		&i.ExpiryDate,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users SET is_active = FALSE WHERE user_id = $1
`

// Deactivate a user
func (q *Queries) DeactivateUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deactivateUser, userID)
	return err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE bookmark_id = $1
`

// Delete a bookmark by its id
func (q *Queries) DeleteBookmark(ctx context.Context, bookmarkID int32) error {
	_, err := q.db.Exec(ctx, deleteBookmark, bookmarkID)
	return err
}

const deleteBookmarksByUser = `-- name: DeleteBookmarksByUser :exec
DELETE FROM bookmarks WHERE user_id = $1
`

// Delete all bookmarks of a user
func (q *Queries) DeleteBookmarksByUser(ctx context.Context, userID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteBookmarksByUser, userID)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE category_id = $1
`

// Delete a category by id
func (q *Queries) DeleteCategory(ctx context.Context, categoryID int32) error {
	_, err := q.db.Exec(ctx, deleteCategory, categoryID)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments WHERE comment_id = $1
`

// Delete a comment by its ID
func (q *Queries) DeleteComment(ctx context.Context, commentID int32) error {
	_, err := q.db.Exec(ctx, deleteComment, commentID)
	return err
}

const deleteCommentByCommentIdAndUserId = `-- name: DeleteCommentByCommentIdAndUserId :exec
DELETE FROM comments WHERE comment_id = $1 AND user_id = $2
`

type DeleteCommentByCommentIdAndUserIdParams struct {
	CommentID int32
	UserID    pgtype.Int4
}

// Delete a comment by its ID and the ID of the user who made it
func (q *Queries) DeleteCommentByCommentIdAndUserId(ctx context.Context, arg DeleteCommentByCommentIdAndUserIdParams) error {
	_, err := q.db.Exec(ctx, deleteCommentByCommentIdAndUserId, arg.CommentID, arg.UserID)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE event_id = $1
`

// Delete a specific event
func (q *Queries) DeleteEvent(ctx context.Context, eventID int32) error {
	_, err := q.db.Exec(ctx, deleteEvent, eventID)
	return err
}

const deleteLog = `-- name: DeleteLog :exec
DELETE FROM forum_moderation_log WHERE log_id = $1
`

func (q *Queries) DeleteLog(ctx context.Context, logID int32) error {
	_, err := q.db.Exec(ctx, deleteLog, logID)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE post_id = $1
`

func (q *Queries) DeletePost(ctx context.Context, postID int32) error {
	_, err := q.db.Exec(ctx, deletePost, postID)
	return err
}

const deletePostByPostIdAndUserId = `-- name: DeletePostByPostIdAndUserId :exec
DELETE FROM posts WHERE post_id = $1 AND user_id = $2
`

type DeletePostByPostIdAndUserIdParams struct {
	PostID int32
	UserID pgtype.Int4
}

func (q *Queries) DeletePostByPostIdAndUserId(ctx context.Context, arg DeletePostByPostIdAndUserIdParams) error {
	_, err := q.db.Exec(ctx, deletePostByPostIdAndUserId, arg.PostID, arg.UserID)
	return err
}

const deletePrivateMessage = `-- name: DeletePrivateMessage :exec
DELETE FROM private_messages WHERE message_id = $1
`

// Delete a private message by its ID
func (q *Queries) DeletePrivateMessage(ctx context.Context, messageID int32) error {
	_, err := q.db.Exec(ctx, deletePrivateMessage, messageID)
	return err
}

const deletePrivateMessagesByReceiverId = `-- name: DeletePrivateMessagesByReceiverId :exec
DELETE FROM private_messages WHERE receiver_user_id = $1
`

// Delete all private messages received by a specific user
func (q *Queries) DeletePrivateMessagesByReceiverId(ctx context.Context, receiverUserID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deletePrivateMessagesByReceiverId, receiverUserID)
	return err
}

const deletePrivateMessagesBySenderId = `-- name: DeletePrivateMessagesBySenderId :exec
DELETE FROM private_messages WHERE sender_user_id = $1
`

// Delete all private messages sent by a specific user
func (q *Queries) DeletePrivateMessagesBySenderId(ctx context.Context, senderUserID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deletePrivateMessagesBySenderId, senderUserID)
	return err
}

const deletePrivateMessagesBySenderIdAndReceiverId = `-- name: DeletePrivateMessagesBySenderIdAndReceiverId :exec
DELETE FROM private_messages WHERE sender_user_id = $1 AND receiver_user_id = $2
`

type DeletePrivateMessagesBySenderIdAndReceiverIdParams struct {
	SenderUserID   pgtype.Int4
	ReceiverUserID pgtype.Int4
}

// Delete all private messages sent by a specific user to another specific user
func (q *Queries) DeletePrivateMessagesBySenderIdAndReceiverId(ctx context.Context, arg DeletePrivateMessagesBySenderIdAndReceiverIdParams) error {
	_, err := q.db.Exec(ctx, deletePrivateMessagesBySenderIdAndReceiverId, arg.SenderUserID, arg.ReceiverUserID)
	return err
}

const deleteRSVP = `-- name: DeleteRSVP :exec
DELETE FROM rsvps WHERE rsvp_id = $1
`

// Delete a specific RSVP
func (q *Queries) DeleteRSVP(ctx context.Context, rsvpID int32) error {
	_, err := q.db.Exec(ctx, deleteRSVP, rsvpID)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE role_id = $1
`

// Delete a role by id
func (q *Queries) DeleteRole(ctx context.Context, roleID int32) error {
	_, err := q.db.Exec(ctx, deleteRole, roleID)
	return err
}

const deleteRoute = `-- name: DeleteRoute :exec
DELETE FROM routes WHERE route_id = $1
`

// Delete a specific route
func (q *Queries) DeleteRoute(ctx context.Context, routeID int32) error {
	_, err := q.db.Exec(ctx, deleteRoute, routeID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE user_id = $1
`

// Delete a user by id
func (q *Queries) DeleteUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
DELETE FROM user_sessions WHERE session_id = $1
`

// Delete a user session
func (q *Queries) DeleteUserSession(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserSession, sessionID)
	return err
}

const getAllCategories = `-- name: GetAllCategories :many
SELECT category_id, name, description FROM categories
`

// Get all categories
func (q *Queries) GetAllCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.CategoryID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllComments = `-- name: GetAllComments :many
SELECT comment_id, content, creation_date, post_id, user_id FROM comments ORDER BY creation_date DESC
`

// Get all comments, ordered by creation date
func (q *Queries) GetAllComments(ctx context.Context) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getAllComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.Content,
			&i.CreationDate,
			&i.PostID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLogs = `-- name: GetAllLogs :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log
`

func (q *Queries) GetAllLogs(ctx context.Context) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getAllLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPosts = `-- name: GetAllPosts :many
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts ORDER BY creation_date DESC
`

func (q *Queries) GetAllPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getAllPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.Content,
			&i.CreationDate,
			&i.UserID,
			&i.IsSticky,
			&i.IsLocked,
			&i.PostCategoryID,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPrivateMessages = `-- name: GetAllPrivateMessages :many
SELECT message_id, content, sender_user_id, receiver_user_id, sent_date, is_read FROM private_messages
`

// Get all private messages
func (q *Queries) GetAllPrivateMessages(ctx context.Context) ([]PrivateMessage, error) {
	rows, err := q.db.Query(ctx, getAllPrivateMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PrivateMessage
	for rows.Next() {
		var i PrivateMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.Content,
			&i.SenderUserID,
			&i.ReceiverUserID,
			&i.SentDate,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT user_id, username, email, registration_date, profile_picture, biography, last_login_date, is_active, role_id FROM users
`

type GetAllUsersRow struct {
	UserID           int32
	Username         string
	Email            string
	RegistrationDate pgtype.Timestamptz
	ProfilePicture   pgtype.Text
	Biography        pgtype.Text
	LastLoginDate    pgtype.Timestamptz
	IsActive         pgtype.Bool
	RoleID           pgtype.Int4
}

// Get all users, no password_hash
func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.RegistrationDate,
			&i.ProfilePicture,
			&i.Biography,
			&i.LastLoginDate,
			&i.IsActive,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmark = `-- name: GetBookmark :one
SELECT bookmark_id, user_id, post_id FROM bookmarks WHERE bookmark_id = $1
`

// Get a bookmark by its id
func (q *Queries) GetBookmark(ctx context.Context, bookmarkID int32) (Bookmark, error) {
	row := q.db.QueryRow(ctx, getBookmark, bookmarkID)
	var i Bookmark
	err := row.Scan(&i.BookmarkID, &i.UserID, &i.PostID)
	return i, err
}

const getBookmarksByPost = `-- name: GetBookmarksByPost :many
SELECT bookmark_id, user_id, post_id FROM bookmarks WHERE post_id = $1 ORDER BY user_id
`

// Get all bookmarks for a post, ordered by user_id
func (q *Queries) GetBookmarksByPost(ctx context.Context, postID pgtype.Int4) ([]Bookmark, error) {
	rows, err := q.db.Query(ctx, getBookmarksByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookmark
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(&i.BookmarkID, &i.UserID, &i.PostID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarksByUser = `-- name: GetBookmarksByUser :many
SELECT bookmark_id, user_id, post_id FROM bookmarks WHERE user_id = $1 ORDER BY bookmark_id
`

// Get all bookmarks of a user, ordered by bookmark_id
func (q *Queries) GetBookmarksByUser(ctx context.Context, userID pgtype.Int4) ([]Bookmark, error) {
	rows, err := q.db.Query(ctx, getBookmarksByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookmark
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(&i.BookmarkID, &i.UserID, &i.PostID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategory = `-- name: GetCategory :one
SELECT category_id, name, description FROM categories WHERE category_id = $1
`

// Get a category by id
func (q *Queries) GetCategory(ctx context.Context, categoryID int32) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, categoryID)
	var i Category
	err := row.Scan(&i.CategoryID, &i.Name, &i.Description)
	return i, err
}

const getComment = `-- name: GetComment :one

SELECT comment_id, content, creation_date, post_id, user_id FROM comments WHERE comment_id = $1
`

// ----------------------------------------------------------------------------------------------------------------------
// Get a single comment by its ID
func (q *Queries) GetComment(ctx context.Context, commentID int32) (Comment, error) {
	row := q.db.QueryRow(ctx, getComment, commentID)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.Content,
		&i.CreationDate,
		&i.PostID,
		&i.UserID,
	)
	return i, err
}

const getCommentsByPost = `-- name: GetCommentsByPost :many
SELECT comment_id, content, creation_date, post_id, user_id FROM comments WHERE post_id = $1 ORDER BY creation_date DESC
`

// Get all comments for a specific post, ordered by creation date
func (q *Queries) GetCommentsByPost(ctx context.Context, postID pgtype.Int4) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.Content,
			&i.CreationDate,
			&i.PostID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByUser = `-- name: GetCommentsByUser :many
SELECT comment_id, content, creation_date, post_id, user_id FROM comments WHERE user_id = $1 ORDER BY creation_date DESC
`

// Get all comments made by a specific user, ordered by creation date
func (q *Queries) GetCommentsByUser(ctx context.Context, userID pgtype.Int4) ([]Comment, error) {
	rows, err := q.db.Query(ctx, getCommentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.Content,
			&i.CreationDate,
			&i.PostID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE event_id = $1
`

// Get a specific event by its ID
func (q *Queries) GetEventByID(ctx context.Context, eventID int32) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, eventID)
	var i Event
	err := row.Scan(
		&i.EventID,
		&i.Title,
		&i.Description,
		&i.EventDate,
		&i.MeetingPoint,
		&i.RouteID,
		&i.CreatorUserID,
	)
	return i, err
}

const getEvents = `-- name: GetEvents :many

SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events ORDER BY event_date
`

// ----------------------------------------------------------------------------------------------------------------------
// Get all events, ordered by event date
func (q *Queries) GetEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByDate = `-- name: GetEventsByDate :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events ORDER BY event_date
`

// Get all events, ordered by event date
func (q *Queries) GetEventsByDate(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByDateRange = `-- name: GetEventsByDateRange :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE event_date >= $1 AND event_date <= $2 ORDER BY event_date
`

type GetEventsByDateRangeParams struct {
	EventDate   pgtype.Timestamptz
	EventDate_2 pgtype.Timestamptz
}

// Get all events within a date range
func (q *Queries) GetEventsByDateRange(ctx context.Context, arg GetEventsByDateRangeParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByDateRange, arg.EventDate, arg.EventDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByDateRangeAndRouteID = `-- name: GetEventsByDateRangeAndRouteID :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE event_date >= $1 AND event_date <= $2 AND route_id = $3 ORDER BY event_date
`

type GetEventsByDateRangeAndRouteIDParams struct {
	EventDate   pgtype.Timestamptz
	EventDate_2 pgtype.Timestamptz
	RouteID     pgtype.Int4
}

// Get all events within a date range for a specific route
func (q *Queries) GetEventsByDateRangeAndRouteID(ctx context.Context, arg GetEventsByDateRangeAndRouteIDParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByDateRangeAndRouteID, arg.EventDate, arg.EventDate_2, arg.RouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByDateRangeAndRouteIDAndUserID = `-- name: GetEventsByDateRangeAndRouteIDAndUserID :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE event_date >= $1 AND event_date <= $2 AND route_id = $3 AND creator_user_id = $4 ORDER BY event_date
`

type GetEventsByDateRangeAndRouteIDAndUserIDParams struct {
	EventDate     pgtype.Timestamptz
	EventDate_2   pgtype.Timestamptz
	RouteID       pgtype.Int4
	CreatorUserID pgtype.Int4
}

// Get all events within a date range for a specific route and user
func (q *Queries) GetEventsByDateRangeAndRouteIDAndUserID(ctx context.Context, arg GetEventsByDateRangeAndRouteIDAndUserIDParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByDateRangeAndRouteIDAndUserID,
		arg.EventDate,
		arg.EventDate_2,
		arg.RouteID,
		arg.CreatorUserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByDateRangeAndUserID = `-- name: GetEventsByDateRangeAndUserID :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE event_date >= $1 AND event_date <= $2 AND creator_user_id = $3 ORDER BY event_date
`

type GetEventsByDateRangeAndUserIDParams struct {
	EventDate     pgtype.Timestamptz
	EventDate_2   pgtype.Timestamptz
	CreatorUserID pgtype.Int4
}

// Get all events within a date range for a specific user
func (q *Queries) GetEventsByDateRangeAndUserID(ctx context.Context, arg GetEventsByDateRangeAndUserIDParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByDateRangeAndUserID, arg.EventDate, arg.EventDate_2, arg.CreatorUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByRouteID = `-- name: GetEventsByRouteID :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE route_id = $1 ORDER BY event_date
`

// Get all events for a specific route
func (q *Queries) GetEventsByRouteID(ctx context.Context, routeID pgtype.Int4) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByRouteID, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByUserID = `-- name: GetEventsByUserID :many
SELECT event_id, title, description, event_date, meeting_point, route_id, creator_user_id FROM events WHERE creator_user_id = $1 ORDER BY event_date
`

// Get all events created by a specific user
func (q *Queries) GetEventsByUserID(ctx context.Context, creatorUserID pgtype.Int4) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventsByUserID, creatorUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.EventID,
			&i.Title,
			&i.Description,
			&i.EventDate,
			&i.MeetingPoint,
			&i.RouteID,
			&i.CreatorUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLockedPosts = `-- name: GetLockedPosts :many
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts WHERE is_locked = TRUE ORDER BY creation_date DESC
`

func (q *Queries) GetLockedPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getLockedPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.Content,
			&i.CreationDate,
			&i.UserID,
			&i.IsSticky,
			&i.IsLocked,
			&i.PostCategoryID,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogById = `-- name: GetLogById :one
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE log_id = $1
`

func (q *Queries) GetLogById(ctx context.Context, logID int32) (ForumModerationLog, error) {
	row := q.db.QueryRow(ctx, getLogById, logID)
	var i ForumModerationLog
	err := row.Scan(
		&i.LogID,
		&i.Action,
		&i.ActionDate,
		&i.ModeratorUserID,
		&i.AffectedUserID,
		&i.PostID,
		&i.CommentID,
		&i.Reason,
	)
	return i, err
}

const getLogsByAction = `-- name: GetLogsByAction :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE action = $1
`

func (q *Queries) GetLogsByAction(ctx context.Context, action string) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByAction, action)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByAffectedUser = `-- name: GetLogsByAffectedUser :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE affected_user_id = $1 ORDER BY action_date DESC
`

func (q *Queries) GetLogsByAffectedUser(ctx context.Context, affectedUserID pgtype.Int4) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByAffectedUser, affectedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByComment = `-- name: GetLogsByComment :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE comment_id = $1
`

func (q *Queries) GetLogsByComment(ctx context.Context, commentID pgtype.Int4) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByComment, commentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByModerator = `-- name: GetLogsByModerator :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE moderator_user_id = $1 ORDER BY action_date DESC
`

func (q *Queries) GetLogsByModerator(ctx context.Context, moderatorUserID pgtype.Int4) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByModerator, moderatorUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByPost = `-- name: GetLogsByPost :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE post_id = $1
`

func (q *Queries) GetLogsByPost(ctx context.Context, postID pgtype.Int4) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByReason = `-- name: GetLogsByReason :many
SELECT log_id, action, action_date, moderator_user_id, affected_user_id, post_id, comment_id, reason FROM forum_moderation_log WHERE reason = $1
`

func (q *Queries) GetLogsByReason(ctx context.Context, reason pgtype.Text) ([]ForumModerationLog, error) {
	rows, err := q.db.Query(ctx, getLogsByReason, reason)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ForumModerationLog
	for rows.Next() {
		var i ForumModerationLog
		if err := rows.Scan(
			&i.LogID,
			&i.Action,
			&i.ActionDate,
			&i.ModeratorUserID,
			&i.AffectedUserID,
			&i.PostID,
			&i.CommentID,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPost = `-- name: GetPost :one
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts WHERE post_id = $1
`

func (q *Queries) GetPost(ctx context.Context, postID int32) (Post, error) {
	row := q.db.QueryRow(ctx, getPost, postID)
	var i Post
	err := row.Scan(
		&i.PostID,
		&i.Title,
		&i.Content,
		&i.CreationDate,
		&i.UserID,
		&i.IsSticky,
		&i.IsLocked,
		&i.PostCategoryID,
		&i.AdditionalNotes,
	)
	return i, err
}

const getPostsByCategory = `-- name: GetPostsByCategory :many
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts WHERE post_category_id = $1 ORDER BY creation_date DESC
`

func (q *Queries) GetPostsByCategory(ctx context.Context, postCategoryID pgtype.Int4) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostsByCategory, postCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.Content,
			&i.CreationDate,
			&i.UserID,
			&i.IsSticky,
			&i.IsLocked,
			&i.PostCategoryID,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUser = `-- name: GetPostsByUser :many
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts WHERE user_id = $1 ORDER BY creation_date DESC
`

func (q *Queries) GetPostsByUser(ctx context.Context, userID pgtype.Int4) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.Content,
			&i.CreationDate,
			&i.UserID,
			&i.IsSticky,
			&i.IsLocked,
			&i.PostCategoryID,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrivateMessageById = `-- name: GetPrivateMessageById :one
SELECT message_id, content, sender_user_id, receiver_user_id, sent_date, is_read FROM private_messages WHERE message_id = $1
`

// Get a private message by its ID
func (q *Queries) GetPrivateMessageById(ctx context.Context, messageID int32) (PrivateMessage, error) {
	row := q.db.QueryRow(ctx, getPrivateMessageById, messageID)
	var i PrivateMessage
	err := row.Scan(
		&i.MessageID,
		&i.Content,
		&i.SenderUserID,
		&i.ReceiverUserID,
		&i.SentDate,
		&i.IsRead,
	)
	return i, err
}

const getPrivateMessagesByReceiverId = `-- name: GetPrivateMessagesByReceiverId :many
SELECT message_id, content, sender_user_id, receiver_user_id, sent_date, is_read FROM private_messages WHERE receiver_user_id = $1 ORDER BY sent_date DESC
`

// Get all private messages received by a specific user
func (q *Queries) GetPrivateMessagesByReceiverId(ctx context.Context, receiverUserID pgtype.Int4) ([]PrivateMessage, error) {
	rows, err := q.db.Query(ctx, getPrivateMessagesByReceiverId, receiverUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PrivateMessage
	for rows.Next() {
		var i PrivateMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.Content,
			&i.SenderUserID,
			&i.ReceiverUserID,
			&i.SentDate,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrivateMessagesBySenderId = `-- name: GetPrivateMessagesBySenderId :many
SELECT message_id, content, sender_user_id, receiver_user_id, sent_date, is_read FROM private_messages WHERE sender_user_id = $1 ORDER BY sent_date DESC
`

// Get all private messages sent by a specific user
func (q *Queries) GetPrivateMessagesBySenderId(ctx context.Context, senderUserID pgtype.Int4) ([]PrivateMessage, error) {
	rows, err := q.db.Query(ctx, getPrivateMessagesBySenderId, senderUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PrivateMessage
	for rows.Next() {
		var i PrivateMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.Content,
			&i.SenderUserID,
			&i.ReceiverUserID,
			&i.SentDate,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSVPByID = `-- name: GetRSVPByID :one
SELECT rsvp_id, event_id, user_id, rsvp_status, rsvp_date FROM rsvps WHERE rsvp_id = $1
`

// Get a specific RSVP by its ID
func (q *Queries) GetRSVPByID(ctx context.Context, rsvpID int32) (Rsvp, error) {
	row := q.db.QueryRow(ctx, getRSVPByID, rsvpID)
	var i Rsvp
	err := row.Scan(
		&i.RsvpID,
		&i.EventID,
		&i.UserID,
		&i.RsvpStatus,
		&i.RsvpDate,
	)
	return i, err
}

const getRSVPs = `-- name: GetRSVPs :many

SELECT rsvp_id, event_id, user_id, rsvp_status, rsvp_date FROM rsvps
`

// ----------------------------------------------------------------------------------------------------------------------
// Get all RSVPs
func (q *Queries) GetRSVPs(ctx context.Context) ([]Rsvp, error) {
	rows, err := q.db.Query(ctx, getRSVPs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rsvp
	for rows.Next() {
		var i Rsvp
		if err := rows.Scan(
			&i.RsvpID,
			&i.EventID,
			&i.UserID,
			&i.RsvpStatus,
			&i.RsvpDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSVPsByEventID = `-- name: GetRSVPsByEventID :many
SELECT rsvp_id, event_id, user_id, rsvp_status, rsvp_date FROM rsvps WHERE event_id = $1
`

// Get all RSVPs for a specific event
func (q *Queries) GetRSVPsByEventID(ctx context.Context, eventID pgtype.Int4) ([]Rsvp, error) {
	rows, err := q.db.Query(ctx, getRSVPsByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rsvp
	for rows.Next() {
		var i Rsvp
		if err := rows.Scan(
			&i.RsvpID,
			&i.EventID,
			&i.UserID,
			&i.RsvpStatus,
			&i.RsvpDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSVPsByEventIDAndUserID = `-- name: GetRSVPsByEventIDAndUserID :many
SELECT rsvp_id, event_id, user_id, rsvp_status, rsvp_date FROM rsvps WHERE event_id = $1 AND user_id = $2
`

type GetRSVPsByEventIDAndUserIDParams struct {
	EventID pgtype.Int4
	UserID  pgtype.Int4
}

// Get all RSVPs for a specific event and user
func (q *Queries) GetRSVPsByEventIDAndUserID(ctx context.Context, arg GetRSVPsByEventIDAndUserIDParams) ([]Rsvp, error) {
	rows, err := q.db.Query(ctx, getRSVPsByEventIDAndUserID, arg.EventID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rsvp
	for rows.Next() {
		var i Rsvp
		if err := rows.Scan(
			&i.RsvpID,
			&i.EventID,
			&i.UserID,
			&i.RsvpStatus,
			&i.RsvpDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSVPsByUserID = `-- name: GetRSVPsByUserID :many
SELECT rsvp_id, event_id, user_id, rsvp_status, rsvp_date FROM rsvps WHERE user_id = $1
`

// Get all RSVPs for a specific user
func (q *Queries) GetRSVPsByUserID(ctx context.Context, userID pgtype.Int4) ([]Rsvp, error) {
	rows, err := q.db.Query(ctx, getRSVPsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rsvp
	for rows.Next() {
		var i Rsvp
		if err := rows.Scan(
			&i.RsvpID,
			&i.EventID,
			&i.UserID,
			&i.RsvpStatus,
			&i.RsvpDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRole = `-- name: GetRole :one
SELECT role_id, role_name FROM roles WHERE role_id = $1
`

// Get a role by id
func (q *Queries) GetRole(ctx context.Context, roleID int32) (Role, error) {
	row := q.db.QueryRow(ctx, getRole, roleID)
	var i Role
	err := row.Scan(&i.RoleID, &i.RoleName)
	return i, err
}

const getRouteByID = `-- name: GetRouteByID :one
SELECT route_id, name, description, start_location, end_location, distance, elevation_gain, route_map_link, user_id FROM routes WHERE route_id = $1
`

// Get a specific route by its ID
func (q *Queries) GetRouteByID(ctx context.Context, routeID int32) (Route, error) {
	row := q.db.QueryRow(ctx, getRouteByID, routeID)
	var i Route
	err := row.Scan(
		&i.RouteID,
		&i.Name,
		&i.Description,
		&i.StartLocation,
		&i.EndLocation,
		&i.Distance,
		&i.ElevationGain,
		&i.RouteMapLink,
		&i.UserID,
	)
	return i, err
}

const getRoutes = `-- name: GetRoutes :many

SELECT route_id, name, description, start_location, end_location, distance, elevation_gain, route_map_link, user_id FROM routes ORDER BY name
`

// ----------------------------------------------------------------------------------------------------------------------
// Get all routes, ordered by name
func (q *Queries) GetRoutes(ctx context.Context) ([]Route, error) {
	rows, err := q.db.Query(ctx, getRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.RouteID,
			&i.Name,
			&i.Description,
			&i.StartLocation,
			&i.EndLocation,
			&i.Distance,
			&i.ElevationGain,
			&i.RouteMapLink,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesByDistance = `-- name: GetRoutesByDistance :many
SELECT route_id, name, description, start_location, end_location, distance, elevation_gain, route_map_link, user_id FROM routes ORDER BY distance
`

// Get all routes, ordered by distance
func (q *Queries) GetRoutesByDistance(ctx context.Context) ([]Route, error) {
	rows, err := q.db.Query(ctx, getRoutesByDistance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.RouteID,
			&i.Name,
			&i.Description,
			&i.StartLocation,
			&i.EndLocation,
			&i.Distance,
			&i.ElevationGain,
			&i.RouteMapLink,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutesByUserID = `-- name: GetRoutesByUserID :many
SELECT route_id, name, description, start_location, end_location, distance, elevation_gain, route_map_link, user_id FROM routes WHERE user_id = $1 ORDER BY name
`

// Get all routes created by a specific user
func (q *Queries) GetRoutesByUserID(ctx context.Context, userID pgtype.Int4) ([]Route, error) {
	rows, err := q.db.Query(ctx, getRoutesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Route
	for rows.Next() {
		var i Route
		if err := rows.Scan(
			&i.RouteID,
			&i.Name,
			&i.Description,
			&i.StartLocation,
			&i.EndLocation,
			&i.Distance,
			&i.ElevationGain,
			&i.RouteMapLink,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStickyPosts = `-- name: GetStickyPosts :many
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts WHERE is_sticky = TRUE ORDER BY creation_date DESC
`

func (q *Queries) GetStickyPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getStickyPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.Content,
			&i.CreationDate,
			&i.UserID,
			&i.IsSticky,
			&i.IsLocked,
			&i.PostCategoryID,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlockedPosts = `-- name: GetUnlockedPosts :many
SELECT post_id, title, content, creation_date, user_id, is_sticky, is_locked, post_category_id, additional_notes FROM posts WHERE is_locked = FALSE ORDER BY creation_date DESC
`

func (q *Queries) GetUnlockedPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getUnlockedPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.Content,
			&i.CreationDate,
			&i.UserID,
			&i.IsSticky,
			&i.IsLocked,
			&i.PostCategoryID,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadPrivateMessagesByReceiverId = `-- name: GetUnreadPrivateMessagesByReceiverId :many
SELECT message_id, content, sender_user_id, receiver_user_id, sent_date, is_read FROM private_messages WHERE receiver_user_id = $1 AND is_read = FALSE ORDER BY sent_date DESC
`

// Get all unread private messages received by a specific user
func (q *Queries) GetUnreadPrivateMessagesByReceiverId(ctx context.Context, receiverUserID pgtype.Int4) ([]PrivateMessage, error) {
	rows, err := q.db.Query(ctx, getUnreadPrivateMessagesByReceiverId, receiverUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PrivateMessage
	for rows.Next() {
		var i PrivateMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.Content,
			&i.SenderUserID,
			&i.ReceiverUserID,
			&i.SentDate,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, username, email, registration_date, profile_picture, biography, last_login_date, is_active, role_id FROM users WHERE user_id = $1
`

type GetUserRow struct {
	UserID           int32
	Username         string
	Email            string
	RegistrationDate pgtype.Timestamptz
	ProfilePicture   pgtype.Text
	Biography        pgtype.Text
	LastLoginDate    pgtype.Timestamptz
	IsActive         pgtype.Bool
	RoleID           pgtype.Int4
}

// Get a user by id, no password_hash
func (q *Queries) GetUser(ctx context.Context, userID int32) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i GetUserRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.RegistrationDate,
		&i.ProfilePicture,
		&i.Biography,
		&i.LastLoginDate,
		&i.IsActive,
		&i.RoleID,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, username, email, password_hash, registration_date, profile_picture, biography, last_login_date, is_active, role_id FROM users WHERE email = $1
`

// Get a user by email
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.RegistrationDate,
		&i.ProfilePicture,
		&i.Biography,
		&i.LastLoginDate,
		&i.IsActive,
		&i.RoleID,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT user_id, username, email, password_hash, registration_date, profile_picture, biography, last_login_date, is_active, role_id FROM users WHERE username = $1
`

// Get a user by username
func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.RegistrationDate,
		&i.ProfilePicture,
		&i.Biography,
		&i.LastLoginDate,
		&i.IsActive,
		&i.RoleID,
	)
	return i, err
}

const getUserSession = `-- name: GetUserSession :one

SELECT session_id, user_id, creation_date, expiry_date, ip_address, user_agent FROM user_sessions WHERE session_id = $1
`

// ----------------------------------------------------------------------------------------------------------------------
// Get a single user session by session_id
func (q *Queries) GetUserSession(ctx context.Context, sessionID pgtype.UUID) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSession, sessionID)
	var i UserSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.CreationDate,
		&i.ExpiryDate,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const getUserSessionAndRoleName = `-- name: GetUserSessionAndRoleName :one
SELECT user_sessions.session_id, user_sessions.user_id, user_sessions.expiry_date, user_sessions.ip_address, user_sessions.user_agent, user_sessions.creation_date, users.role_id, roles.role_name
FROM user_sessions
INNER JOIN users ON user_sessions.user_id = users.user_id
INNER JOIN roles ON users.role_id = roles.role_id
WHERE session_id = $1
`

type GetUserSessionAndRoleNameRow struct {
	SessionID    pgtype.UUID
	UserID       pgtype.Int4
	ExpiryDate   pgtype.Timestamptz
	IpAddress    *netip.Addr
	UserAgent    pgtype.Text
	CreationDate pgtype.Timestamptz
	RoleID       pgtype.Int4
	RoleName     string
}

// Get a single user session by session_id, with role_name
func (q *Queries) GetUserSessionAndRoleName(ctx context.Context, sessionID pgtype.UUID) (GetUserSessionAndRoleNameRow, error) {
	row := q.db.QueryRow(ctx, getUserSessionAndRoleName, sessionID)
	var i GetUserSessionAndRoleNameRow
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.ExpiryDate,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreationDate,
		&i.RoleID,
		&i.RoleName,
	)
	return i, err
}

const getUserSessionsByDate = `-- name: GetUserSessionsByDate :many
SELECT session_id, user_id, creation_date, expiry_date, ip_address, user_agent FROM user_sessions WHERE DATE(creation_date) = $1
`

// Get all sessions created on a specific date
func (q *Queries) GetUserSessionsByDate(ctx context.Context, creationDate pgtype.Date) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessionsByDate, creationDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreationDate,
			&i.ExpiryDate,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionsByIP = `-- name: GetUserSessionsByIP :many
SELECT session_id, user_id, creation_date, expiry_date, ip_address, user_agent FROM user_sessions WHERE ip_address = $1
`

// Get all sessions from a specific IP address
func (q *Queries) GetUserSessionsByIP(ctx context.Context, ipAddress *netip.Addr) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessionsByIP, ipAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreationDate,
			&i.ExpiryDate,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionsByUserId = `-- name: GetUserSessionsByUserId :many
SELECT session_id, user_id, creation_date, expiry_date, ip_address, user_agent FROM user_sessions WHERE user_id = $1
`

// Get all sessions for a specific user_id
func (q *Queries) GetUserSessionsByUserId(ctx context.Context, userID pgtype.Int4) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessionsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreationDate,
			&i.ExpiryDate,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionsFilteredByDate = `-- name: GetUserSessionsFilteredByDate :many
SELECT session_id, user_id, creation_date, expiry_date, ip_address, user_agent FROM user_sessions WHERE creation_date > $1
`

// Get all user sessions after a specific date
func (q *Queries) GetUserSessionsFilteredByDate(ctx context.Context, creationDate pgtype.Timestamptz) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessionsFilteredByDate, creationDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreationDate,
			&i.ExpiryDate,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionsOrderedByDate = `-- name: GetUserSessionsOrderedByDate :many
SELECT session_id, user_id, creation_date, expiry_date, ip_address, user_agent FROM user_sessions ORDER BY creation_date
`

// Get all user sessions ordered by creation_date
func (q *Queries) GetUserSessionsOrderedByDate(ctx context.Context) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessionsOrderedByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.SessionID,
			&i.UserID,
			&i.CreationDate,
			&i.ExpiryDate,
			&i.IpAddress,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithRoleName = `-- name: GetUserWithRoleName :one
SELECT users.user_id, users.username, users.email, users.registration_date, users.profile_picture, users.biography, users.last_login_date, users.is_active, users.role_id, roles.role_name
FROM users
INNER JOIN roles ON users.role_id = roles.role_id
WHERE users.user_id = $1
`

type GetUserWithRoleNameRow struct {
	UserID           int32
	Username         string
	Email            string
	RegistrationDate pgtype.Timestamptz
	ProfilePicture   pgtype.Text
	Biography        pgtype.Text
	LastLoginDate    pgtype.Timestamptz
	IsActive         pgtype.Bool
	RoleID           pgtype.Int4
	RoleName         string
}

// Get a user by id, no password_hash, with role_name
func (q *Queries) GetUserWithRoleName(ctx context.Context, userID int32) (GetUserWithRoleNameRow, error) {
	row := q.db.QueryRow(ctx, getUserWithRoleName, userID)
	var i GetUserWithRoleNameRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.RegistrationDate,
		&i.ProfilePicture,
		&i.Biography,
		&i.LastLoginDate,
		&i.IsActive,
		&i.RoleID,
		&i.RoleName,
	)
	return i, err
}

const invalidateUserSession = `-- name: InvalidateUserSession :exec
UPDATE user_sessions SET expiry_date = TIMESTAMP '1970-01-01 00:00:00' WHERE session_id = $1
`

// Invalidate a user session by setting the expiry_date to a past date
func (q *Queries) InvalidateUserSession(ctx context.Context, sessionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, invalidateUserSession, sessionID)
	return err
}

const listRoles = `-- name: ListRoles :many
SELECT role_id, role_name FROM roles
`

// Get all roles
func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.RoleID, &i.RoleName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockPost = `-- name: LockPost :exec
UPDATE posts SET is_locked = TRUE WHERE post_id = $1
`

func (q *Queries) LockPost(ctx context.Context, postID int32) error {
	_, err := q.db.Exec(ctx, lockPost, postID)
	return err
}

const markPrivateMessageAsRead = `-- name: MarkPrivateMessageAsRead :exec
UPDATE private_messages SET is_read = TRUE WHERE message_id = $1
`

// Mark a private message as read
func (q *Queries) MarkPrivateMessageAsRead(ctx context.Context, messageID int32) error {
	_, err := q.db.Exec(ctx, markPrivateMessageAsRead, messageID)
	return err
}

const stickyPost = `-- name: StickyPost :exec
UPDATE posts SET is_sticky = TRUE WHERE post_id = $1
`

func (q *Queries) StickyPost(ctx context.Context, postID int32) error {
	_, err := q.db.Exec(ctx, stickyPost, postID)
	return err
}

const unlockPost = `-- name: UnlockPost :exec
UPDATE posts SET is_locked = FALSE WHERE post_id = $1
`

func (q *Queries) UnlockPost(ctx context.Context, postID int32) error {
	_, err := q.db.Exec(ctx, unlockPost, postID)
	return err
}

const unstickyPost = `-- name: UnstickyPost :exec
UPDATE posts SET is_sticky = FALSE WHERE post_id = $1
`

func (q *Queries) UnstickyPost(ctx context.Context, postID int32) error {
	_, err := q.db.Exec(ctx, unstickyPost, postID)
	return err
}

const updateBookmark = `-- name: UpdateBookmark :exec
UPDATE bookmarks SET user_id = $2, post_id = $3 WHERE bookmark_id = $1
`

type UpdateBookmarkParams struct {
	BookmarkID int32
	UserID     pgtype.Int4
	PostID     pgtype.Int4
}

// Update a bookmark
func (q *Queries) UpdateBookmark(ctx context.Context, arg UpdateBookmarkParams) error {
	_, err := q.db.Exec(ctx, updateBookmark, arg.BookmarkID, arg.UserID, arg.PostID)
	return err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories SET name = $2, description = $3 WHERE category_id = $1
`

type UpdateCategoryParams struct {
	CategoryID  int32
	Name        string
	Description pgtype.Text
}

// Update a category by id
func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.Exec(ctx, updateCategory, arg.CategoryID, arg.Name, arg.Description)
	return err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comments SET content = $2 WHERE comment_id = $1 RETURNING comment_id, content, creation_date, post_id, user_id
`

type UpdateCommentParams struct {
	CommentID int32
	Content   string
}

// Update a comment's content
func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.CommentID, arg.Content)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.Content,
		&i.CreationDate,
		&i.PostID,
		&i.UserID,
	)
	return i, err
}

const updateCommentByCommentIdAndUserId = `-- name: UpdateCommentByCommentIdAndUserId :one
UPDATE comments SET content = $3 WHERE comment_id = $1 AND user_id = $2 RETURNING comment_id, content, creation_date, post_id, user_id
`

type UpdateCommentByCommentIdAndUserIdParams struct {
	CommentID int32
	UserID    pgtype.Int4
	Content   string
}

// Update a comment's content by its ID and the ID of the user who made it
func (q *Queries) UpdateCommentByCommentIdAndUserId(ctx context.Context, arg UpdateCommentByCommentIdAndUserIdParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateCommentByCommentIdAndUserId, arg.CommentID, arg.UserID, arg.Content)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.Content,
		&i.CreationDate,
		&i.PostID,
		&i.UserID,
	)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE events SET title = $2, description = $3, event_date = $4, meeting_point = $5, route_id = $6, creator_user_id = $7
WHERE event_id = $1
`

type UpdateEventParams struct {
	EventID       int32
	Title         string
	Description   pgtype.Text
	EventDate     pgtype.Timestamptz
	MeetingPoint  string
	RouteID       pgtype.Int4
	CreatorUserID pgtype.Int4
}

// Update a specific event
func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent,
		arg.EventID,
		arg.Title,
		arg.Description,
		arg.EventDate,
		arg.MeetingPoint,
		arg.RouteID,
		arg.CreatorUserID,
	)
	return err
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE users SET last_login_date = CURRENT_TIMESTAMP WHERE user_id = $1
`

// Update a user's last login date
func (q *Queries) UpdateLastLogin(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, updateLastLogin, userID)
	return err
}

const updateLog = `-- name: UpdateLog :exec
UPDATE forum_moderation_log
SET action = $2, moderator_user_id = $3, affected_user_id = $4, post_id = $5, comment_id = $6, reason = $7
WHERE log_id = $1
`

type UpdateLogParams struct {
	LogID           int32
	Action          string
	ModeratorUserID pgtype.Int4
	AffectedUserID  pgtype.Int4
	PostID          pgtype.Int4
	CommentID       pgtype.Int4
	Reason          pgtype.Text
}

func (q *Queries) UpdateLog(ctx context.Context, arg UpdateLogParams) error {
	_, err := q.db.Exec(ctx, updateLog,
		arg.LogID,
		arg.Action,
		arg.ModeratorUserID,
		arg.AffectedUserID,
		arg.PostID,
		arg.CommentID,
		arg.Reason,
	)
	return err
}

const updatePost = `-- name: UpdatePost :exec
UPDATE posts SET title = $2, content = $3, user_id = $4, post_category_id = $5, additional_notes = $6 WHERE post_id = $1
`

type UpdatePostParams struct {
	PostID          int32
	Title           string
	Content         string
	UserID          pgtype.Int4
	PostCategoryID  pgtype.Int4
	AdditionalNotes pgtype.Text
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) error {
	_, err := q.db.Exec(ctx, updatePost,
		arg.PostID,
		arg.Title,
		arg.Content,
		arg.UserID,
		arg.PostCategoryID,
		arg.AdditionalNotes,
	)
	return err
}

const updatePrivateMessage = `-- name: UpdatePrivateMessage :exec
UPDATE private_messages SET content = $2 WHERE message_id = $1
`

type UpdatePrivateMessageParams struct {
	MessageID int32
	Content   string
}

// Update the content of a private message
func (q *Queries) UpdatePrivateMessage(ctx context.Context, arg UpdatePrivateMessageParams) error {
	_, err := q.db.Exec(ctx, updatePrivateMessage, arg.MessageID, arg.Content)
	return err
}

const updateRSVP = `-- name: UpdateRSVP :exec
UPDATE rsvps SET event_id = $2, user_id = $3 WHERE rsvp_id = $1
`

type UpdateRSVPParams struct {
	RsvpID  int32
	EventID pgtype.Int4
	UserID  pgtype.Int4
}

// Update a specific RSVP
func (q *Queries) UpdateRSVP(ctx context.Context, arg UpdateRSVPParams) error {
	_, err := q.db.Exec(ctx, updateRSVP, arg.RsvpID, arg.EventID, arg.UserID)
	return err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles SET role_name = $2 WHERE role_id = $1
`

type UpdateRoleParams struct {
	RoleID   int32
	RoleName string
}

// Update a role by id
func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) error {
	_, err := q.db.Exec(ctx, updateRole, arg.RoleID, arg.RoleName)
	return err
}

const updateRoute = `-- name: UpdateRoute :exec
UPDATE routes SET name = $2, description = $3, start_location = $4, end_location = $5, distance = $6, elevation_gain = $7, route_map_link = $8, user_id = $9
WHERE route_id = $1
`

type UpdateRouteParams struct {
	RouteID       int32
	Name          string
	Description   pgtype.Text
	StartLocation string
	EndLocation   string
	Distance      pgtype.Float8
	ElevationGain pgtype.Int4
	RouteMapLink  pgtype.Text
	UserID        pgtype.Int4
}

// Update a specific route
func (q *Queries) UpdateRoute(ctx context.Context, arg UpdateRouteParams) error {
	_, err := q.db.Exec(ctx, updateRoute,
		arg.RouteID,
		arg.Name,
		arg.Description,
		arg.StartLocation,
		arg.EndLocation,
		arg.Distance,
		arg.ElevationGain,
		arg.RouteMapLink,
		arg.UserID,
	)
	return err
}

const updateUserExcludingSensitive = `-- name: UpdateUserExcludingSensitive :exec
UPDATE users SET username = $2, email = $3, profile_picture = $4, biography = $5 WHERE user_id = $1
`

type UpdateUserExcludingSensitiveParams struct {
	UserID         int32
	Username       string
	Email          string
	ProfilePicture pgtype.Text
	Biography      pgtype.Text
}

// Update a user's details, no password_hash
func (q *Queries) UpdateUserExcludingSensitive(ctx context.Context, arg UpdateUserExcludingSensitiveParams) error {
	_, err := q.db.Exec(ctx, updateUserExcludingSensitive,
		arg.UserID,
		arg.Username,
		arg.Email,
		arg.ProfilePicture,
		arg.Biography,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = $2 WHERE user_id = $1
`

type UpdateUserPasswordParams struct {
	UserID       int32
	PasswordHash string
}

// Update a user's password_hash
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.UserID, arg.PasswordHash)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role_id = $2 WHERE user_id = $1
`

type UpdateUserRoleParams struct {
	UserID int32
	RoleID pgtype.Int4
}

// Update a user's role
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.UserID, arg.RoleID)
	return err
}

const updateUserSession = `-- name: UpdateUserSession :exec
UPDATE user_sessions SET user_id = $2, expiry_date = $3, ip_address = $4, user_agent = $5 WHERE session_id = $1
`

type UpdateUserSessionParams struct {
	SessionID  pgtype.UUID
	UserID     pgtype.Int4
	ExpiryDate pgtype.Timestamptz
	IpAddress  *netip.Addr
	UserAgent  pgtype.Text
}

// Update a user session
func (q *Queries) UpdateUserSession(ctx context.Context, arg UpdateUserSessionParams) error {
	_, err := q.db.Exec(ctx, updateUserSession,
		arg.SessionID,
		arg.UserID,
		arg.ExpiryDate,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}
